<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Clone with Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Tetris Clone</h1>
        <p>Use arrow keys to move and rotate the blocks.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set up lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        scene.add(directionalLight);

        // Define Tetris grid dimensions
        const gridWidth = 10;
        const gridHeight = 20;
        const blockSize = 1;

        // Create grid
        const grid = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(null));

        // Define Tetris shapes
        const shapes = [
            [[1, 1, 1, 1]], // I
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1, 0], [0, 1, 1]], // Z
            [[0, 1, 1], [1, 1, 0]], // S
            [[1, 1], [1, 1]], // O
            [[1, 1, 1], [1, 0, 0]], // L
            [[1, 1, 1], [0, 0, 1]]  // J
        ];

        // Current falling shape
        let currentShape = null;
        let currentPosition = { x: 4, y: 0 };

        // Create a new shape
        function createShape() {
            const shapeIndex = Math.floor(Math.random() * shapes.length);
            currentShape = shapes[shapeIndex];
            currentPosition = { x: 4, y: 0 };
        }

        // Draw the shape on the grid
        function drawShape() {
            currentShape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set((currentPosition.x + x) * blockSize, (gridHeight - currentPosition.y - y) * blockSize, 0);
                        scene.add(cube);
                    }
                });
            });
        }

        // Check collision
        function checkCollision(xOffset, yOffset) {
            return currentShape.some((row, y) => {
                return row.some((value, x) => {
                    if (value) {
                        const newX = currentPosition.x + x + xOffset;
                        const newY = currentPosition.y + y + yOffset;
                        if (newX < 0 || newX >= gridWidth || newY >= gridHeight || (newY >= 0 && grid[newY][newX])) {
                            return true;
                        }
                    }
                    return false;
                });
            });
        }

        // Move shape
        function moveShape(xOffset, yOffset) {
            if (!checkCollision(xOffset, yOffset)) {
                currentPosition.x += xOffset;
                currentPosition.y += yOffset;
            }
        }

        // Rotate shape
        function rotateShape() {
            const rotatedShape = currentShape[0].map((_, index) => currentShape.map(row => row[index]).reverse());
            const originalShape = currentShape;
            currentShape = rotatedShape;
            if (checkCollision(0, 0)) {
                currentShape = originalShape;
            }
        }

        // Lock shape into grid
        function lockShape() {
            currentShape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        grid[currentPosition.y + y][currentPosition.x + x] = 1;
                    }
                });
            });
        }

        // Clear full lines
        function clearLines() {
            for (let y = gridHeight - 1; y >= 0; y--) {
                if (grid[y].every(value => value)) {
                    grid.splice(y, 1);
                    grid.unshift(Array(gridWidth).fill(null));
                }
            }
        }

        // Game loop
        function gameLoop() {
            if (!currentShape) {
                createShape();
            }
            if (!checkCollision(0, 1)) {
                moveShape(0, 1);
            } else {
                lockShape();
                clearLines();
                createShape();
            }
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        // Handle keyboard input
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowLeft':
                    moveShape(-1, 0);
                    break;
                case 'ArrowRight':
                    moveShape(1, 0);
                    break;
                case 'ArrowDown':
                    moveShape(0, 1);
                    break;
                case 'ArrowUp':
                    rotateShape();
                    break;
            }
        });

        // Set camera position
        camera.position.z = 30;

        // Start game loop
        gameLoop();
    </script>
</body>
</html>